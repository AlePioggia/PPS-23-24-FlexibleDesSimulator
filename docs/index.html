<!DOCTYPE html>
<html>
<head>
    <title>Project Documentation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            font-size: 30px;
            color: #333;
        }
        nav {
            width: 200px;
            height: 100vh;
            background-color: #333;
            color: #fff;
            position: fixed;
            overflow-y: auto;
            transition: width 0.3s;
            z-index: 1000;
        }
        nav:hover {
            width: 250px;
        }
        nav ul {
            padding: 0;
            list-style: none;
            margin: 0;
        }
        nav a {
            display: block;
            color: #fff;
            text-decoration: none;
            padding: 15px;
            transition: background-color 0.3s;
        }
        nav a:hover {
            background-color: #555;
        }
        main {
            margin-left: 200px;
            padding: 20px;
            background-color: #fff;
            min-height: 100vh;
        }
        section {
            margin-bottom: 20px;
        }
        h2 {
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        h3 {
            margin-top: 20px;
            color: #555;
        }
        ul {
            padding-left: 20px;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px 0;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 90%;
        }
    </style>
</head>
<body>
    <nav>
        <h2>Contents</h2>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#development-methodology">Development Methodology</a></li>
            <li><a href="#system-analysis">System Analysis</a></li>
            <li><a href="#architectural-design">Architectural Design</a></li>
            <li><a href="#detailed-design">Detailed Design</a></li>
            <li><a href="#implementation">Implementation</a></li>
            <li><a href="#conclusions">Conclusions</a></li>
        </ul>
    </nav>
    
    <main>
        <section id="introduction">
            <h2>Introduction</h2>
            <p>In today's dynamic world, the study and application of swarm intelligence have become increasingly relevant across various fields, from optimization problems to robotics. 
                To facilitate experimentation and exploration within this domain, we have developed a discrete event simulation (DES) framework with a core designed to be technology-agnostic. 
                This framework prioritizes modularity, extensibility, and flexibility, enabling the seamless integration of diverse swarm intelligence strategies without necessitating alterations to the simulation core.</p>
            <h3>Project Objectives</h3>
            <p>The primary goal of this project was to create a simulation engine detached from specific swarm intelligence strategies.
                 This engine serves as a foundation for the development and integration of various swarm intelligence approaches, allowing for agile experimentation and comparison.</p>
            <ol>
                <li><strong>Simulation Engine Development:</strong> Creation of a versatile simulation engine capable of supporting different swarm intelligence strategies, independent of their implementation specifics.</li>
                <li><strong>Modularity:</strong> Ensuring that the framework's architecture allows for the easy integration of new swarm intelligence strategies, promoting adaptability and scalability.</li>
                <li><strong>Extensibility:</strong> Designing the system in a manner that facilitates the addition of new functionalities and features, catering to evolving research and application needs.</li>
                <li><strong>Implementation of Classic Strategies:</strong> Incorporating well-established swarm intelligence strategies such as Ant Colony Optimization (ACO), Swarm Robotics, Boids, among others, to provide a foundational set of examples and benchmarks.</li>
                <li><strong>Graphical Interface:</strong> Developing a user-friendly graphical interface that enables visualization of simulation results, enhancing usability and comprehension.</li>
                <li><strong>Statistical Analysis:</strong> Implementing statistical calculations to generate insightful reports, aiding in the evaluation and comparison of different swarm intelligence strategies.</li>
            </ol>
        </section>
        
        <section id="development-methodology">
            <h2>Development Methodology</h2>
            <p>This section outlines the development methodology followed in the project.</p>
            
            <h3>Technologies Used</h3>
            <ul>
                <li><strong>Travis CI:</strong> Continuous integration service for automated builds and tests.</li>
                <li><strong>ScalaTest:</strong> Testing framework for Scala.</li>
                <li><strong>Scoverage:</strong> Tool for measuring code coverage.</li>
                <li><strong>Codium:</strong> Service for test coverage verification using artificial intelligence.</li>
                <li><strong>SBT:</strong> Build automation tool for Scala projects.</li>
                <li><strong>FindBugs and Scalastyle:</strong> Tools for static code analysis and applying code styling conventions.</li>
            </ul>
        </section>
        
        <section id="system-analysis">
            <h2>System Analysis</h2>
            <p>The requirements analysis phase is crucial for understanding the needs and expectations of the stakeholders, guiding the subsequent stages of system development.</p>

            <h3>Business requirements</h3>
            <ul>
                <li><strong>Provide a solid discrete event simulator</strong> which allows users to experiment without encountering problems</li>
                <li><strong>Client-side</strong> create an application that can be seen as a valide base for forks</li>
            </ul>

            <h3>Functional requirements</h3>
            <ul>
                <li><strong>Step-by-step</strong> simulation, every step is activated by the user via UI</li>
                <li><strong>Real time</strong> stats and simulation state</li>
                <li><strong>Pause</strong> and <strong>resume</strong> simulation</li>
                <li><strong>Report</strong> stats on an external file, including parameters</li>
                <li><strong>Graphical</strong> representation of the simulation</li>
                <li><strong>Multiple</strong> swarm selection from toggle menu</li>
                <li>
                    <strong>Swarm</strong> parameters:
                    <ul>
                        <li>Number of agents</li>
                        <li>Initial position</li>
                        <li>Initial velocity</li>
                        <li>Initial direction</li>
                        <li>Initial energy</li>
                        <li>Initial state</li>
                    </ul>
                </li>
            </ul>

            <h3>Non-functional requirements</h3>
            <ul>
                <li><strong>Raw</strong> interface, it has to work correctly but it's not the main focus</li>
                <li><strong>Good</strong> performance on simulations with small amount of objects (single thread execution)</li>
            </ul>

        </section>
        
        <section id="architectural-design">
            <h2>Architectural Design</h2>
            <p>The chosen architecture employs the Model View Controller (MVC) pattern, which ensures flexibility, modularity, and most importantly, allows the creation of an agnostic core with a well-defined structure.
                To this end, an abstract structure has been developed to provide base classes for various swarms that extend them. By leveraging patterns such as the Template Method, code reuse is maximized, making the code structure much more concise.
                Through MVC, the separation of concerns is prioritized, ensuring flexibility and allowing modifications to portions of the code independently from others. The simulation is governed by the controller, which utilizes the logic implemented in the model.</p>
            <img src="arch_mvc.png" alt="Architecture Diagram" style="width: 80%;">
        </section>
        
        <section id="detailed-design">
            <h2>Detailed Design</h2>

            <h3>Environment Structure</h3>
            <p>
                The system simulates a virtual environment where agents and objects interact within a defined grid. The <code>Grid</code> 
                trait acts as a blueprint for any grid-based environment. The design focuses on modularity, flexibility, and maintainability 
                to accommodate future enhancements and changes. The simulation occurs within the <code>Environment</code> class, which extends 
                the <code>Grid</code> trait. The environment is represented by a matrix of dimensions <code>height x width</code>, where cells 
                can contain agents and objects. Agents move and interact with objects based on specific logic. By leveraging design patterns 
                like the Template Method and principles such as composition over inheritance, the system can easily accommodate future 
                enhancements and changes.
            </p>
        
            <h3>Composition</h3>
            <p>
                Since the <code>Environment</code> can easily become a god-class, having to deal with a lot of dynamics, the use of composition 
                is very useful. It enhances the separation of concerns principle by allowing independent component testing. It also favors 
                encapsulation, which hides the complexity of these operations from the <code>Environment</code> class, making it simpler and more 
                focused on high-level functionality.
            </p>

            <h3>Template method</h3>
            <p>
                As can be seen in the <code>Environment</code> class, the moveAgent method is based off 3 methods, <code>preMoveActions(agent: Agent)</code>, <code>postMoveActions(agent: Agent)</code> and <code>interactWithObject(agent: Agent)</code> 
                which are implemented by the extending classes. This allows for a more concise code structure and promotes code reuse.
            </p>

            <img src="detailed_environment.png" alt="Environment architecture Diagram" style="width: 80%;">

            <h3>Detailed robot</h3>

            This section aims to describe the detail design of the robot (robotswarm scope), which is perhaps the most complex agent, is explored in depth, in this regard.
            Key aspects of this design include the use of scala's traits for modularity, enums for type safety and companion objects for controlled object creation and incapsulation. The focus was to favour
            flexibility and maintainability, allowing for easy extension and modification of the robot's behaviour.

            <img src="detailed_robot.png" alt="robot architecture" style="width: 80%;">

            <h4>Encapsulation</h4>

            The design leverages encapsulation effectively by employing nested classes within the Robot companion object, this approach hides implementation details and ensures that the internal workings of the robot are not exposed.
            By keeping BaseRobotImpl and RobotImpl private as inner classes of the Robot object, the design enforces encapsulation and prevents direct access to these classes from external sources.

            <h4>Trait composition</h4>

            The Robot trait is composed of multiple traits, each responsible for a specific aspect of the robot's functionality. The baseRobot trait implements basic robot functionalities, by extending the Robot trait. This trait 
            is intended to be used by other traits or classes to provide a foundation without needing to duplicate the implementation. 
            The batteryPowered trait adds complexity, by expliciting battery management. By using abstract override it extends the behaviour of the move method.

            <h4>Design patters used</h4>

            The apply methods in the companion object facilitate the Robot's instances creation, by providing a factory method for the creation of different types of robots. 
            The trait composition is linked with the strategy pattern, as it allows for the dynamic selection of behaviours at runtime. 
            The template method pattern is also used, as the move method is defined in the Robot trait and implemented in the extending classes.

        </section>
        
        
        <section id="implementation">
            <h2>Implementation</h2>
            <h3>A* algorithm</h3>
            <p>
                One of the core features of the project is the artificial intelligence implemented for the robot swarm. 
                In particular, I chose to use the A* algorithm for finding the optimal path from point A to point B. Since the robot operates in a 2D environment, I implemented the A* algorithm to consider only horizontal and vertical movements.
                For each robot, the path to optimally reach the target was calculated in advance. To achieve this, it was necessary to also create a taskAllocator, which, based on a distance calculation, assigns tasks to robots 
                (one-to-one with objects) in an optimal manner. The paths were converted into iterators so that each robot can move towards the target at each step. Specifically, the iterator is reversible, allowing the use of the previous() 
                function to go backward if needed.
                The challenge lies in the fact that:
            </p>
            <ul>
                <li>Robots must collect only their own objects;</li>
                <li>The code shown indicates the main method, omitting some private methods for clarity.</li>
            </ul>

            <h4><strong>Architecture</strong></h4>

            Simple and straightforward, just 2 main classes and some utilities are enough to implement the A* algorithm. The main classes are:

            <img src="AStar_impl.png" alt="aStar" style="width: 80%;">

            <h4><strong>Findpath</strong></h4>

            The findPath method is the implementation of the AStar algorithm. The mechanisms and choices are explained below:
            <img src="Astar_code.png" alt="aStarCode" style="width: 80%;">
            <h4>Priority queue</h4>
            A mutable priority queue was used to keep track of nodes to be evaluated, prioritized by their fscore. This ensures that the node with the lowest estimated total cost is processed first.
            <h4>Data structures</h4>
            <ul>
                <li>cameFrom is a map to reconstruct the path once the goal is reached. It records the most efficient predecessor of each node;</li>
                <li>gscore is a map storing the cost of the path from the start node to each node;</li>
                <li>fscore is a map, storing the estimated total cost to reach the goal from each node. Initialized similarly to gscore.</li>
            </ul>
            <h4>Heuristic</h4>
            The heuristic used is the Manhattan distance, which is suitable for environments where movements are restricted to horizontal and vertical directions.
            <h4>Algorithm</h4>
            <ul>
                <li>Initialize the starting node with a gScore of 0 and an fscore of +infinite, based on the Manhattan distance to the goal;</li>
                <li>continuosly dequeue the node with the lowest fscore from the openSet and check if it is the goal node;</li>
                <li>for each neighbor of the current node, if it isn't an obstacle, calculate the tentative gscore and update it if the new path is shorter;</li>
                <li>update the cameFrom, gScore and fScore maps accordingly and add the neighbor to the openSet if it's not already present.</li>
            </ul>
            <h4>Performance</h4>
            he priority queue operations are efficient but can be impacted by the number of nodes. In practice, the A* algorithm performs well with appropriate heuristics and can handle large-scale environments effectively. 
            Optimizations may include using more sophisticated data structures or heuristics tailored to specific environments.

            <h4><strong>Task allocator</strong></h4>

            The TaskAllocator object is designed to assign tasks to a set of robots based on their proximity to a list of objects. The core functionality is implemented in the assignTasks method, which uses a greedy approach to ensure each robot is allocated the closest available object.
            This approach is straightforward and effective for scenarios where tasks need to be dynamically assigned based on real-time conditions.
            
            <img src="Task_Allocator_code.png" alt="taskAllocatorCode" style="width: 80%;">
        </section>
        
        <section id="conclusions">
            <h2>Conclusions</h2>
            <p>This is the conclusions section.</p>
        </section>
    </main>
</body>
</html>
