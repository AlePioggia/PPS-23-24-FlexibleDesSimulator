<!DOCTYPE html>
<html>
<head>
    <title>Project Documentation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            font-size: 30px;
            color: #333;
        }
        nav {
            width: 200px;
            height: 100vh;
            background-color: #333;
            color: #fff;
            position: fixed;
            overflow-y: auto;
            transition: width 0.3s;
            z-index: 1000;
        }
        nav:hover {
            width: 250px;
        }
        nav ul {
            padding: 0;
            list-style: none;
            margin: 0;
        }
        nav a {
            display: block;
            color: #fff;
            text-decoration: none;
            padding: 15px;
            transition: background-color 0.3s;
        }
        nav a:hover {
            background-color: #555;
        }
        main {
            margin-left: 200px;
            padding: 20px;
            background-color: #fff;
            min-height: 100vh;
        }
        section {
            margin-bottom: 20px;
        }
        h2 {
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        h3 {
            margin-top: 20px;
            color: #555;
        }
        ul {
            padding-left: 20px;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px 0;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 90%;
        }
    </style>
</head>
<body>
    <nav>
        <h2>Contents</h2>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#development-methodology">Development Methodology</a></li>
            <li><a href="#system-analysis">System Analysis</a></li>
            <li><a href="#architectural-design">Architectural Design</a></li>
            <li><a href="#detailed-design">Detailed Design</a></li>
            <li><a href="#implementation">Implementation</a></li>
            <li><a href="#conclusions">Conclusions</a></li>
        </ul>
    </nav>
    
    <main>
        <section id="introduction">
            <h2>Introduction</h2>
            <p>In today's dynamic world, the study and application of swarm intelligence have become increasingly relevant across various fields, from optimization problems to robotics. 
                To facilitate experimentation and exploration within this domain, a discrete event simulation <a href="https://en.wikipedia.org/wiki/Discrete-event_simulation">DES</a> framework was developed, with a core designed to be technology-agnostic. 
                This framework prioritizes modularity, extensibility, and flexibility, enabling the seamless integration of diverse swarm intelligence strategies without necessitating alterations to the simulation core.
                
                Swarm intelligence is a collective behavior exhibited by decentralized, self-organized systems, such as social insect colonies or flocks of birds. 
                These systems demonstrate emergent properties that enable them to solve complex problems more efficiently than individual agents, often drawing inspiration from natural phenomena.
                These are the swarms chosen for this project:            
            </p>
                
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant Colony Optimization (ACO)</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Swarm_robotics">Swarm Robotics</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Particle_swarm_optimization">Particle Swarm Optimization (PSO)</a></li>
                </ul>

                <h3>SWARM ROBOTICS<h3>

                <p>Swarm robotics is a field that involves the coordination of multiple robots to achieve a common goal. These robots interact with each other and their environment to perform tasks that would be challenging or impossible for a single robot.
                In this particular case I chose to make robots collect objects in a 2D environment, by calculating the optimal path in order to save energy and time. It can be seen as an object picking problem, like in a warehouse,
                where robots have to collect objects and bring them to a specific location.</p>

                <h3>ANT COLONY OPTIMIZATION</h3> 

                <p>Ant colony optimization (ACO) is a metaheuristic optimization algorithm inspired by the foraging behavior of ants. ACO algorithms are used to solve combinatorial optimization problems by simulating the behavior of ant colonies
                searching for food. It differs from swarm robotics because, while in the case of swarm robots the robots follow a precise path with very low variability, in the case of ACO the agents move in the environment based on the pheromones released by other ants.</p>

                <h3>PARTICLE SWARM OPTIMIZATION</h3>

                <p>
                Particle swarm optimization (PSO) is a population-based optimization algorithm inspired by the social behavior of birds flocking or fish schooling, where individuals adjust their positions based on their own experience and the experience of their neighbors.
                PSO algorithms are used to solve optimization problems by simulating the movement of particles in a search space, with each particle representing a potential solution to the problem.
                </p>

            <h3>Project Objectives</h3>
            <p>The primary goal of this project was to create a simulation engine detached from specific swarm intelligence strategies.
                 This engine serves as a foundation for the development and integration of various swarm intelligence approaches, allowing for agile experimentation and comparison.</p>
            <ol>
                <li><strong>Simulation Engine Development:</strong> Creation of a versatile simulation engine capable of supporting different swarm intelligence strategies, independent of their implementation specifics.</li>
                <li><strong>Modularity:</strong> Ensuring that the framework's architecture allows for the easy integration of new swarm intelligence strategies, promoting adaptability and scalability.</li>
                <li><strong>Extensibility:</strong> Designing the system in a manner that facilitates the addition of new functionalities and features, catering to evolving research and application needs.</li>
                <li><strong>Implementation of Classic Strategies:</strong> Incorporating well-established swarm intelligence strategies such as Ant Colony Optimization (ACO), Swarm Robotics, Boids, among others, to provide a foundational set of examples and benchmarks.</li>
                <li><strong>Graphical Interface:</strong> Developing a user-friendly graphical interface that enables visualization of simulation results, enhancing usability and comprehension.</li>
                <li><strong>Statistical Analysis:</strong> Implementing statistical calculations to generate insightful reports, aiding in the evaluation and comparison of different swarm intelligence strategies.</li>
            </ol>
        </section>
        
        <section id="development-methodology">
            <h2>Development Methodology</h2>
            <p>The development of the simulation engine and swarm intelligence strategies was guided by the principles of test-driven development (TDD), build automation, and continuous integration. </p>

            <h3>Test driven development</h3>
            <p>Test-driven development (TDD) is a software development approach that emphasizes writing tests before writing the actual code. This practice ensures that the code is testable, reliable, and meets the specified requirements.
                It was strictly followed the red-green-refactor rule, which involves writing a failing test (red), implementing the code to pass the test (green), and refactoring the code to improve its design and maintainability. 
                The tests were written using <strong>ScalaTest</strong>, a testing framework for Scala, which provides a wide range of features for writing different types of tests, such as unit tests, integration tests, and acceptance tests.
                Codium was also used to verify test coverage, providing insights into the effectiveness of the test suite and identifying areas that require additional testing.
            </p>
            <h3>Build automation</h3>
            <p>
                In this project, <strong>SBT (Scala Build Tool)</strong> was used to automate the build process, manage dependencies, and run tests. 
                SBT simplifies the development workflow by providing a unified interface for compiling, testing, and packaging the code. It also facilitates the integration of third-party libraries and tools, enhancing productivity and code quality.
            </p>
            <h3>Continuos integration</h3>
            <p>
                <strong>Travis CI</strong> was used for continuous integration, automating the build and test process for every code commit. 
                This practice ensures that the codebase remains stable and functional throughout the development cycle, enabling early detection of bugs and issues. 
                The integration with Travis CI also provides insights into the test results and code coverage, helping maintain a high-quality codebase.
            </p>

            <h3>Technologies used (recap)</h3>
            <ul>
                <li><strong>Travis CI:</strong> Continuous integration service for automated builds and tests.</li>
                <li><strong>ScalaTest:</strong> Testing framework for Scala.</li>
                <li><strong>Scoverage:</strong> Tool for measuring code coverage.</li>
                <li><strong>Codium:</strong> Service for test coverage verification using artificial intelligence.</li>
                <li><strong>SBT:</strong> Build automation tool for Scala projects.</li>
            </ul>
        </section>
        
        <section id="system-analysis">
            <h2>System Analysis</h2>
        
            <h3>Business requirements</h3>
            <ul>
                <li><strong>Provide a solid discrete event simulator</strong> which allows users to experiment without encountering problems</li>
                <li><strong>Client-side</strong> provide an extensible and valid framework for academic purpouse</li>
            </ul>

            <h3>Functional requirements</h3>
            
            <h4>Simulation Type Selection:</h4>
            <ul>
                <li>The user can choose from three types of simulations:</li>
                <ul>
                    <li><strong>Robot Swarm</strong></li>
                    <li><strong>Particle Swarm Optimization (PSO)</strong></li>
                    <li><strong>Ant Colony Optimization (ACO)</strong></li>
                </ul>
            </ul>
            
            <h4>Simulation Parameters Configuration:</h4>
            <ul>
                <li><strong>Robot Swarm:</strong></li>
                <ul>
                    <li>The user can select the number of agents (robots).</li>
                    <li>The items to be collected are randomly distributed on the map.</li>
                </ul>
                <li><strong>Particle Swarm Optimization (PSO):</strong></li>
                <ul>
                    <li>The user can set parameters related to the fitness function.</li>
                    <li>The simulation seeks the optimal solution based on these parameters.</li>
                </ul>
                <li><strong>Ant Colony Optimization (ACO):</strong></li>
                <ul>
                    <li>The ant colony searches for food.</li>
                    <li>The simulation ends when all the food has been brought back to the bases (default configuration).</li>
                </ul>
            </ul>
            
            <h4>Simulation Execution:</h4>
            <ul>
                <li>The user starts the selected simulation.</li>
                <li>During execution, the current step count is displayed.</li>
                <li>Real-time statistics related to the ongoing simulation are shown.</li>
            </ul>
            
            <h4>Statistics Display:</h4>
            <ul>
                <li>During the simulation, the user can see updated statistics, which may include:</li>
                <ul>
                    <li>Current simulation status (e.g., position of robots/ants).</li>
                    <li>Number of steps taken.</li>
                    <li>Progress towards the objective (e.g., number of items collected or amount of food transported).</li>
                </ul>
            </ul>
            
            <h4>Solution Output:</h4>
            <ul>
                <li>At the end of the simulation, a solution is returned:</li>
                <ul>
                    <li><strong>Robot Swarm:</strong> Number of items collected and the path followed by the robots.</li>
                    <li><strong>Particle Swarm Optimization (PSO):</strong> Optimal solution found based on the fitness function.</li>
                    <li><strong>Ant Colony Optimization (ACO):</strong> Final state of the colony and amount of food transported to the bases.</li>
                </ul>
            </ul>
            
            <h4>User Actions:</h4>
            <ul>
                <li><strong>Start and Stop Simulations:</strong> The user can start or stop a simulation at any time.</li>
                <li><strong>Modify Parameters:</strong> The user can configure the specific parameters of each type of simulation before starting it.</li>
                <li><strong>Monitor Real-Time Status:</strong> During execution, the user can observe the step count and real-time statistics.</li>
                <li><strong>View and Analyze Results:</strong> At the end of the simulation, the user can view the final results and use them for further analysis or decision-making.</li>
            </ul>
            <h3>Non-functional requirements</h3>
            <ul>
                <li><strong>Raw</strong> interface, it has to work correctly but it's not the main focus</li>
                <li><strong>Good</strong> performance on simulations with small amount of objects (single thread execution)</li>
            </ul>

        </section>
        
        <section id="architectural-design">
            <h2>Architectural Design</h2>
            <p>The chosen architecture employs the Model View Controller (MVC) pattern, which ensures flexibility, modularity, and most importantly, allows the creation of an agnostic core with a well-defined structure.
                To this end, an abstract structure has been developed to provide base classes for various swarms that extend them. By leveraging patterns such as the Template Method, code reuse is maximized, making the code structure much more concise.
                Through MVC, the separation of concerns is prioritized, ensuring flexibility and allowing modifications to portions of the code independently from others. The simulation is governed by the controller, which utilizes the logic implemented in the model.</p>
            <img src="arch_mvc.png" alt="Architecture Diagram" style="width: 80%;">
        </section>
        
        <section id="detailed-design">
            <h2>Detailed Design</h2>

            <h3>Des simulator (core)</h3>

            This section discusses the design of the project core, which is a des, agnostic simulator that is able to process a series of discrete events by exploiting a priority queue.

            <img src="basic_simulator.png" alt="Environment architecture Diagram" style="width: 80%;">

            <h4>Event</h4>

            Event trait represents the base structure of an event, which is defined by its time, it favours type-safety.

            <h4>State management</h4>

            The simulator uses State, an enumeration useful to track its execution status and to manage the simulation lifecycle.

            <h4>Simulation</h4>

            Simualtor trait is projects' core, it defines the basic structure of a simulation, which is composed of a priority queue of events and a state. 
            The simulation is started by calling the start method, which sets the state to running and processes the events in the queue until the state changes to stopped. 
            Basic simulator is a concrete implementation of the simulator trait, which serves these purposes:
            <ul>
                <li>provide a base, working implementation of a DES, while incapsulating simulation state and event handling;</li>
                <li>leverage the Template Method pattern to define the basic execution flow, while allowing subclasses to modify or extend specific steps, in order to fit the individual swarm;</li>
                <li>separate concerns, the handleEvent method is intended to be overridden to implement specific behaviours, while the simulator remains unchanged.</li>
            </ul>

            <h3>Environment Structure</h3>
            <p>
                The system simulates a virtual environment where agents and objects interact within a defined grid. The <code>Grid</code> 
                trait acts as a blueprint for any grid-based environment. The design focuses on modularity, flexibility, and maintainability 
                to accommodate future enhancements and changes. The simulation occurs within the <code>Environment</code> class, which extends 
                the <code>Grid</code> trait. The environment is represented by a matrix of dimensions <code>height x width</code>, where cells 
                can contain agents and objects. Agents move and interact with objects based on specific logic. By leveraging design patterns 
                like the Template Method and principles such as composition over inheritance, the system can easily accommodate future 
                enhancements and changes.
            </p>
        
            <h3>Composition</h3>
            <p>
                Since the <code>Environment</code> can easily become a god-class, having to deal with a lot of dynamics, the use of composition 
                is very useful. It enhances the separation of concerns principle by allowing independent component testing. It also favors 
                encapsulation, which hides the complexity of these operations from the <code>Environment</code> class, making it simpler and more 
                focused on high-level functionality.
            </p>

            <h3>Template method</h3>
            <p>
                As can be seen in the <code>Environment</code> class, the moveAgent method is based off 3 methods, <code>preMoveActions(agent: Agent)</code>, <code>postMoveActions(agent: Agent)</code> and <code>interactWithObject(agent: Agent)</code> 
                which are implemented by the extending classes. This allows for a more concise code structure and promotes code reuse.
            </p>

            <img src="detailed_environment.png" alt="Environment architecture Diagram" style="width: 80%;">

            <h3>Detailed robot</h3>

            This section aims to describe the detail design of the robot (robotswarm scope), which is perhaps the most complex agent, is explored in depth, in this regard.
            Key aspects of this design include the use of scala's traits for modularity, enums for type safety and companion objects for controlled object creation and incapsulation. The focus was to favour
            flexibility and maintainability, allowing for easy extension and modification of the robot's behaviour.

            <img src="detailed_robot.png" alt="robot architecture" style="width: 50%; height: 50%">

            <h4>Encapsulation</h4>

            The design leverages encapsulation effectively by employing nested classes within the Robot companion object, this approach hides implementation details and ensures that the internal workings of the robot are not exposed.
            By keeping BaseRobotImpl and RobotImpl private as inner classes of the Robot object, the design enforces encapsulation and prevents direct access to these classes from external sources.

            <h4>Trait composition</h4>

            The Robot trait is composed of multiple traits, each responsible for a specific aspect of the robot's functionality. The baseRobot trait implements basic robot functionalities, by extending the Robot trait. This trait 
            is intended to be used by other traits or classes to provide a foundation without needing to duplicate the implementation. 
            The batteryPowered trait adds complexity, by expliciting battery management. By using abstract override it extends the behaviour of the move method.

            <h4>Design patters used</h4>

            The apply methods in the companion object facilitate the Robot's instances creation, by providing a factory method for the creation of different types of robots. 
            The trait composition is linked with the strategy pattern, as it allows for the dynamic selection of behaviours at runtime. 
            The template method pattern is also used, as the move method is defined in the Robot trait and implemented in the extending classes.

            <h3>Ant swarm on detail</h3>
            <p>
                The AntSwarmSimulator system simulates a virtual environment where ants, represented as agents, interact with objects like food sources and pheromones on a grid. 
                Since it's a core's extension, the design is similar to the RobotSwarmSimulator, with some differences due to the implementation specifics.
            </p>

            <img src="ants_architecture.png" alt="ants architecture" style="width: 80%;">

            <h4>Pheromone manager</h4>

            The PheromoneManager manages the pheromone levels in the environment, ensuring that pheromones decay over time and are increased when ants deposit them. 
            The manager handles the pheromones, maintaining both the strength of the pheromones and their sources (ant IDs).

            <h4>Ant</h4>

            Ant, as shown in the UML diagram, is a class that extends Agent and abstracts the behavior of an ant. Specifically, each ant stores:
            <ul>
              <li>the position of the nest, which is a predefined point in the environment where it must deposit the collected food</li>
              <li>the state `carryingFood`; if the ant has collected food, it will attempt to deposit it, otherwise, it will search for food by following pheromones.</li>
            </ul>


        <h3>Particle swarm architecture</h3>

        Even though pso swarm is more interesting implementation wise, it's still important to notice some key architecture aspects, and choices.

        <img src="pos_architecture.png" alt="pso architecture" style="width: 80%;">

        As can be seen from the diagram, in order to build the PSO swarm environment, the builder pattern was used, due to high number of parameters needed.
        In order to favour flexibility, the PSOEnvironment is composed of multiple traits, each responsible for a specific aspect of the PSO swarm functionality. 
        Position utils provides utility methods for handling particle positions, while the calculateVelocity trait calculates the velocity of particles based on their current position and the global best position. 
        </section>
        
        <section id="implementation">
            <h2>Implementation</h2>
            <h3>A* algorithm</h3>
            <p>
                One of the core features of the project is the artificial intelligence implemented for the robot swarm. 
                In particular, I chose to use the A* algorithm for finding the optimal path from point A to point B. Since the robot operates in a 2D environment, I implemented the A* algorithm to consider only horizontal and vertical movements.
                For each robot, the path to optimally reach the target was calculated in advance. To achieve this, it was necessary to also create a taskAllocator, which, based on a distance calculation, assigns tasks to robots 
                (one-to-one with objects) in an optimal manner. The paths were converted into iterators so that each robot can move towards the target at each step. Specifically, the iterator is reversible, allowing the use of the previous() 
                function to go backward if needed.
                The challenge lies in the fact that:
            </p>
            <ul>
                <li>Robots must collect only their own objects;</li>
                <li>The code shown indicates the main method, omitting some private methods for clarity.</li>
            </ul>

            <h4><strong>Architecture</strong></h4>

            Simple and straightforward, just 2 main classes and some utilities are enough to implement the A* algorithm. The main classes are:

            <img src="AStar_impl.png" alt="aStar" style="width: 80%;">

            <h4><strong>Findpath</strong></h4>

            The findPath method is the implementation of the AStar algorithm. The mechanisms and choices are explained below:
            <img src="Astar_code.png" alt="aStarCode" style="width: 80%;">
            <h4>Priority queue</h4>
            A mutable priority queue was used to keep track of nodes to be evaluated, prioritized by their fscore. This ensures that the node with the lowest estimated total cost is processed first.
            <h4>Data structures</h4>
            <ul>
                <li>cameFrom is a map to reconstruct the path once the goal is reached. It records the most efficient predecessor of each node;</li>
                <li>gscore is a map storing the cost of the path from the start node to each node;</li>
                <li>fscore is a map, storing the estimated total cost to reach the goal from each node. Initialized similarly to gscore.</li>
            </ul>
            <h4>Heuristic</h4>
            The heuristic used is the Manhattan distance, which is suitable for environments where movements are restricted to horizontal and vertical directions.
            <h4>Algorithm</h4>
            <ul>
                <li>Initialize the starting node with a gScore of 0 and an fscore of +infinite, based on the Manhattan distance to the goal;</li>
                <li>continuosly dequeue the node with the lowest fscore from the openSet and check if it is the goal node;</li>
                <li>for each neighbor of the current node, if it isn't an obstacle, calculate the tentative gscore and update it if the new path is shorter;</li>
                <li>update the cameFrom, gScore and fScore maps accordingly and add the neighbor to the openSet if it's not already present.</li>
            </ul>
            <h4>Performance</h4>
            he priority queue operations are efficient but can be impacted by the number of nodes. In practice, the A* algorithm performs well with appropriate heuristics and can handle large-scale environments effectively. 
            Optimizations may include using more sophisticated data structures or heuristics tailored to specific environments.

            <h4><strong>Task allocator</strong></h4>

            The TaskAllocator object is designed to assign tasks to a set of robots based on their proximity to a list of objects. 
            The core functionality is implemented in the assignTasks method, which uses a greedy approach to ensure each robot is allocated the closest available object.
            This approach is straightforward and effective for scenarios where tasks need to be dynamically assigned based on real-time conditions.
            
            <img src="Task_Allocator_code.png" alt="taskAllocatorCode" style="width: 80%;">

            <h3>Particle swarm optimization (PSO)</h3>
            
            <img src="pos_posEnvironment.png" alt="taskAllocatorCode" style="width: 80%;">

            Fields:

            <ul>
                <li><code>globalBest</code> is the best position found by all particles so far;</li>
                <li><code>globalBestFitness</code> is the fitness value associated with the globalBest, initialized to the highest possible value</li>
            </ul>


            Methods:

            <ul>
                <li><code>nextPosition</code> computes the particle's next position, based on its velocity. The new position is bounded and must be valid;</li>
                <li><code>updatePersonalBests(particle: Particle)</code>if the particle's current position has better fitness value than its personal best, it updates it;</li>
                <li><code>updateGlobalBests(particle: Particle)</code> same as updatePersonalBests but with global best as landmark;</li>
                <li><code>preMoveActions(agent: Agents)</code> executes a set of actions before a particle moves, in this case, it calculates nextPosition;</li>
                <li><code>postMoveActions(agent: Agents)</code> executes a set of actions after a move, in particular this method checks particle's fitness value. If the current position has a better fitness than its personalBest, it updates the value. If the particleìs fitness is better than the globalBest, it updates the globalBest as well.</li>
            </ul>


            <img src="pos_calculateVelocity.png" alt="taskAllocatorCode" style="width: 80%;">

            VelocityUtils contains calculateVelocity, which updates particle position based on current velocity (inertia), global best (best position found till now during the simulation), and these params:
            
            <ul>
                <li>w: inertia factor</li>
                <li>c1: parameter that controls how much a particle is attracted to its personal best</li>
                <li>c2: parameter that controls how much a particle is attracted to the global best</li>
                <li>r1, r2: two random factors used to introduce diversity in the particle's behavior</li>
            </ul>            

            <img src="pos_positionUtils.png" alt="taskAllocatorCode" style="width: 80%;">

            PositionUtils provides utility methods for handling particle positions, its methods are:
            <ul>
                <li><code>findValidPosition</code> generates infinite random positions, and returns the first free one</li>
                <li><code>boundPosition</code>it assures that particles remain inside its boundaries</li>
                <li><code>distance</code> </li>
            </ul>

        </section>
        
        <section id="conclusions">
            <h2>Conclusions</h2>
            <p>This is the conclusions section.</p>
        </section>
    </main>
</body>
</html>
